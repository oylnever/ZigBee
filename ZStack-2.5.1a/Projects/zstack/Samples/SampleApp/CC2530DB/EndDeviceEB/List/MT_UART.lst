###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               04/Sep/2021  12:32:41
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Components\mt\MT_UART.c
#    Command line       =  
#        -f C:\Users\OY\AppData\Local\Temp\EW6574.tmp
#        (C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Components\mt\MT_UART.c -D
#        NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -lC
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB\List
#        -lA
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFF1
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\Source\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Ohz --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB\List\MT_UART.lst
#    Object file        =  
#        C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB\Obj\MT_UART.r51
#
###############################################################################

C:\Users\OY\Desktop\ing\new\ZStack-2.5.1a\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          #include "MT_AF.h"
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define CMD_STATE1     0x01
     61          #define CMD_STATE2     0x02
     62          #define LEN_STATE      0x03
     63          #define DATA_STATE     0x04
     64          #define FCS_STATE      0x05
     65          
     66          /***************************************************************************************************
     67           *                                         GLOBAL VARIABLES
     68           ***************************************************************************************************/
     69          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     70          byte App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     71          
     72          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          uint8 state;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  CMD_Token[2];
   \                     CMD_Token:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     75          uint8  LEN_Token;
   \                     LEN_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     76          uint8  FSC_Token;
   \                     FSC_Token:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     77          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     78          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     79          
     80          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     81          uint16  MT_UartMaxZAppBufLen;
     82          bool    MT_UartZAppRxStatus;
     83          #endif
     84          
     85          
     86          /***************************************************************************************************
     87           *                                          LOCAL FUNCTIONS
     88           ***************************************************************************************************/
     89          
     90          /***************************************************************************************************
     91           * @fn      MT_UartInit
     92           *
     93           * @brief   Initialize MT with UART support
     94           *
     95           * @param   None
     96           *
     97           * @return  None
     98          ***************************************************************************************************/
     99          extern void SampleApp_CallBack(uint8 port, uint8 event);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    100          void MT_UartInit ()
   \                     MT_UartInit:
    101          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV       A,#-0x1d
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
    102            halUARTCfg_t uartConfig;
    103          
    104            /* Initialize APP ID */
    105            App_TaskID = 0;
   \   000009   90....       MOV       DPTR,#App_TaskID
   \   00000C   E4           CLR       A
   \   00000D   F0           MOVX      @DPTR,A
    106          
    107            /* UART Configuration */
    108            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    109            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   7404         MOV       A,#0x4
   \   00001B   F0           MOVX      @DPTR,A
    110            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
    111            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000023   7403         MOV       A,#0x3
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   747D         MOV       A,#0x7d
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
    112            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002E   740A         MOV       A,#0xa
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   74FA         MOV       A,#-0x6
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
    113            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000039   7412         MOV       A,#0x12
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   74FA         MOV       A,#-0x6
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   E4           CLR       A
   \   000043   F0           MOVX      @DPTR,A
    114            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000044   7405         MOV       A,#0x5
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   7406         MOV       A,#0x6
   \   00004B   F0           MOVX      @DPTR,A
    115            uartConfig.intEnable            = TRUE;
   \   00004C   7416         MOV       A,#0x16
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   7401         MOV       A,#0x1
   \   000053   F0           MOVX      @DPTR,A
    116          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    117            uartConfig.callBackFunc         = SampleApp_CallBack;
   \   000054   741B         MOV       A,#0x1b
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   74..         MOV       A,#`??SampleApp_CallBack::?relay` & 0xff
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   74..         MOV       A,#(`??SampleApp_CallBack::?relay` >> 8) & 0xff
   \   00005F   F0           MOVX      @DPTR,A
    118          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    119            uartConfig.callBackFunc         = SampleApp_CallBack;
    120          #else
    121            uartConfig.callBackFunc         = NULL;
    122          #endif
    123          
    124            /* Start UART */
    125          #if defined (MT_UART_DEFAULT_PORT)
    126            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   000060                ; Setup parameters for call to function HalUARTOpen
   \   000060   AA..         MOV       R2,?XSP + 0
   \   000062   AB..         MOV       R3,?XSP + 1
   \   000064   7900         MOV       R1,#0x0
   \   000066   12....       LCALL     `??HalUARTOpen::?relay`; Banked call to: HalUARTOpen
    127          
    128            //³õÊ¼Ê¼»¯´®¿Ú1
    129          //  HalUARTOpen (HAL_UART_PORT_1, &uartConfig); //Ô­±¾×¢ÊÍ
    130          #else
    131            /* Silence IAR compiler warning */
    132            (void)uartConfig;
    133          #endif
    134          
    135            /* Initialize for ZApp */
    136          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    137            /* Default max bytes that ZAPP can take */
    138            MT_UartMaxZAppBufLen  = 1;
    139            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    140          #endif
    141          
    142          }
   \   000069   741D         MOV       A,#0x1d
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006E                REQUIRE ?Subroutine0
   \   00006E                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    143          
    144          /***************************************************************************************************
    145           * @fn      MT_SerialRegisterTaskID
    146           *
    147           * @brief   This function registers the taskID of the application so it knows
    148           *          where to send the messages whent they come in.
    149           *
    150           * @param   void
    151           *
    152           * @return  void
    153           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    154          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    155          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    156            App_TaskID = taskID;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   F0           MOVX      @DPTR,A
    157          }
   \   000009   80..         SJMP      ?Subroutine0
    158          
    159          /***************************************************************************************************
    160           * @fn      SPIMgr_CalcFCS
    161           *
    162           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    163           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    164           *
    165           * @param   byte *msg_ptr - message pointer
    166           * @param   byte len - length (in bytes) of message
    167           *
    168           * @return  result byte
    169           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    170          byte MT_UartCalcFCS( uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    171          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV       A,R1
   \   000005   FC           MOV       R4,A
    172            byte x;
    173            byte xorResult;
    174          
    175            xorResult = 0;
   \   000006   7900         MOV       R1,#0x0
    176          
    177            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000008   7800         MOV       R0,#0x0
   \   00000A   800E         SJMP      ??MT_UartCalcFCS_0
    178              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   00000C   8A82         MOV       DPL,R2
   \   00000E   8B83         MOV       DPH,R3
   \   000010   E0           MOVX      A,@DPTR
   \   000011   C9           XCH       A,R1
   \   000012   69           XRL       A,R1
   \   000013   F9           MOV       R1,A
   \   000014   08           INC       R0
   \   000015   A3           INC       DPTR
   \   000016   AA82         MOV       R2,DPL
   \   000018   AB83         MOV       R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   00001A   E8           MOV       A,R0
   \   00001B   C3           CLR       C
   \   00001C   9C           SUBB      A,R4
   \   00001D   40ED         JC        ??MT_UartCalcFCS_1
    179          
    180            return ( xorResult );
   \   00001F   80..         SJMP      ?Subroutine0
    181          }
    182          
    183          
    184          /***************************************************************************************************
    185           * @fn      MT_UartProcessZToolData
    186           *
    187           * @brief   | SOP | Data Length  |   CMD   |   Data   |  FCS  |
    188           *          |  1  |     1        |    2    |  0-Len   |   1   |
    189           *
    190           *          Parses the data and determine either is SPI or just simply serial data
    191           *          then send the data to correct place (MT or APP)
    192           *
    193           * @param   port     - UART port
    194           *          event    - Event that causes the callback
    195           *
    196           *
    197           * @return  None
    198           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    199          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    200          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    201            uint8  ch;
    202            uint8  bytesInRxBuffer;
    203            
    204            (void)event;  // Intentionally unreferenced parameter
   \   00000C   8029         SJMP      ??MT_UartProcessZToolData_0
    205          
    206            while (Hal_UART_RxBufLen(port))
    207            {
    208              HalUARTRead (port, &ch, 1);
    209          
    210              switch (state)
    211              {
    212                case SOP_STATE:
    213                  if (ch == MT_UART_SOF)
    214                    state = LEN_STATE;
    215                  break;
    216          
    217                case LEN_STATE:
    218                  LEN_Token = ch;
    219          
    220                  tempDataLen = 0;
    221          
    222                  /* Allocate memory for the data */
    223                  pMsg = (mtOSALSerialData_t *)osal_msg_allocate( sizeof ( mtOSALSerialData_t ) +
    224                                                                  MT_RPC_FRAME_HDR_SZ + LEN_Token );
    225          
    226                  if (pMsg)
    227                  {
    228                    /* Fill up what we can */
    229                    pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F583         MOV       DPH,A
   \   000011   8A82         MOV       DPL,R2
   \   000013   7401         MOV       A,#0x1
   \   000015   F0           MOVX      @DPTR,A
    230                    pMsg->msg = (uint8*)(pMsg+1);
   \   000016   90....       MOV       DPTR,#pMsg
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   2404         ADD       A,#0x4
   \   00001C   F8           MOV       R0,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   3400         ADDC      A,#0x0
   \   000021   F9           MOV       R1,A
   \   000022   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000025   E8           MOV       A,R0
   \   000026   F0           MOVX      @DPTR,A
   \   000027   A3           INC       DPTR
   \   000028   E9           MOV       A,R1
   \   000029   12....       LCALL     ?Subroutine4 & 0xFFFF
    231                    pMsg->msg[MT_RPC_POS_LEN] = LEN_Token;
   \                     ??CrossCallReturnLabel_6:
   \   00002C   8882         MOV       DPL,R0
   \   00002E   8983         MOV       DPH,R1
   \   000030   F0           MOVX      @DPTR,A
    232                    state = CMD_STATE1;
   \   000031   90....       MOV       DPTR,#state
   \   000034   7401         MOV       A,#0x1
   \                     ??MT_UartProcessZToolData_2:
   \   000036   F0           MOVX      @DPTR,A
    233                  }
    234                  else
    235                  {
    236                    state = SOP_STATE;
    237                    return;
    238                  }
    239                  break;
   \                     ??MT_UartProcessZToolData_0:
   \   000037                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000037   EE           MOV       A,R6
   \   000038   F9           MOV       R1,A
   \   000039   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   00003C   EA           MOV       A,R2
   \   00003D   4B           ORL       A,R3
   \   00003E   7003         JNZ       $+5
   \   000040   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
   \   000043                ; Setup parameters for call to function HalUARTRead
   \   000043   7C01         MOV       R4,#0x1
   \   000045   7D00         MOV       R5,#0x0
   \   000047   AA..         MOV       R2,?XSP + 0
   \   000049   AB..         MOV       R3,?XSP + 1
   \   00004B   EE           MOV       A,R6
   \   00004C   F9           MOV       R1,A
   \   00004D   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   000050   90....       MOV       DPTR,#state
   \   000053   E0           MOVX      A,@DPTR
   \   000054   6017         JZ        ??MT_UartProcessZToolData_4
   \   000056   14           DEC       A
   \   000057   605A         JZ        ??MT_UartProcessZToolData_5
   \   000059   14           DEC       A
   \   00005A   606E         JZ        ??MT_UartProcessZToolData_6
   \   00005C   14           DEC       A
   \   00005D   6020         JZ        ??MT_UartProcessZToolData_7
   \   00005F   14           DEC       A
   \   000060   7003         JNZ       $+5
   \   000062   02....       LJMP      ??MT_UartProcessZToolData_8 & 0xFFFF
   \   000065   14           DEC       A
   \   000066   7003         JNZ       $+5
   \   000068   02....       LJMP      ??MT_UartProcessZToolData_9 & 0xFFFF
   \   00006B   80CA         SJMP      ??MT_UartProcessZToolData_0
   \                     ??MT_UartProcessZToolData_4:
   \   00006D   85..82       MOV       DPL,?XSP + 0
   \   000070   85..83       MOV       DPH,?XSP + 1
   \   000073   E0           MOVX      A,@DPTR
   \   000074   64FE         XRL       A,#0xfe
   \   000076   70BF         JNZ       ??MT_UartProcessZToolData_0
   \   000078   90....       MOV       DPTR,#state
   \   00007B   7403         MOV       A,#0x3
   \   00007D   80B7         SJMP      ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_7:
   \   00007F   85..82       MOV       DPL,?XSP + 0
   \   000082   85..83       MOV       DPH,?XSP + 1
   \   000085   E0           MOVX      A,@DPTR
   \   000086   90....       MOV       DPTR,#LEN_Token
   \   000089   F0           MOVX      @DPTR,A
   \   00008A   90....       MOV       DPTR,#tempDataLen
   \   00008D   E4           CLR       A
   \   00008E   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000091   2407         ADD       A,#0x7
   \   000093   FA           MOV       R2,A
   \   000094   E4           CLR       A
   \   000095   3400         ADDC      A,#0x0
   \   000097   FB           MOV       R3,A
   \   000098   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   00009B   90....       MOV       DPTR,#pMsg
   \   00009E   EA           MOV       A,R2
   \   00009F   F0           MOVX      @DPTR,A
   \   0000A0   A3           INC       DPTR
   \   0000A1   EB           MOV       A,R3
   \   0000A2   F0           MOVX      @DPTR,A
   \   0000A3   F9           MOV       R1,A
   \   0000A4   EA           MOV       A,R2
   \   0000A5   49           ORL       A,R1
   \   0000A6   6003         JZ        $+5
   \   0000A8   02....       LJMP      ??MT_UartProcessZToolData_1 & 0xFFFF
   \   0000AB   90....       MOV       DPTR,#state
   \   0000AE   E4           CLR       A
   \   0000AF   F0           MOVX      @DPTR,A
   \   0000B0   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
    240          
    241                case CMD_STATE1:
    242                  pMsg->msg[MT_RPC_POS_CMD0] = ch;
   \                     ??MT_UartProcessZToolData_5:
   \   0000B3   85..82       MOV       DPL,?XSP + 0
   \   0000B6   85..83       MOV       DPH,?XSP + 1
   \   0000B9   E0           MOVX      A,@DPTR
   \   0000BA   C0E0         PUSH      A
   \   0000BC   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000BF   D0E0         POP       A
   \   0000C1   F0           MOVX      @DPTR,A
    243                  state = CMD_STATE2;
   \   0000C2   90....       MOV       DPTR,#state
   \   0000C5   7402         MOV       A,#0x2
   \   0000C7   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    244                  break;
    245          
    246                case CMD_STATE2:
    247                  pMsg->msg[MT_RPC_POS_CMD1] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000CA   85..82       MOV       DPL,?XSP + 0
   \   0000CD   85..83       MOV       DPH,?XSP + 1
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   C0E0         PUSH      A
   \   0000D3   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000D6   A3           INC       DPTR
   \   0000D7   D0E0         POP       A
   \   0000D9   12....       LCALL     ?Subroutine4 & 0xFFFF
    248                  /* If there is no data, skip to FCS state */
    249                  if (LEN_Token)
   \                     ??CrossCallReturnLabel_8:
   \   0000DC   607F         JZ        ??MT_UartProcessZToolData_10
    250                  {
    251                    state = DATA_STATE;
   \   0000DE   90....       MOV       DPTR,#state
   \   0000E1   7404         MOV       A,#0x4
   \   0000E3   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    252                  }
    253                  else
    254                  {
    255                    state = FCS_STATE;
    256                  }
    257                  break;
    258          
    259                case DATA_STATE:
    260          
    261                  /* Fill in the buffer the first byte of the data */
    262                  pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen++] = ch;
   \                     ??MT_UartProcessZToolData_8:
   \   0000E6   85..82       MOV       DPL,?XSP + 0
   \   0000E9   85..83       MOV       DPH,?XSP + 1
   \   0000EC   E0           MOVX      A,@DPTR
   \   0000ED   C0E0         PUSH      A
   \   0000EF   90....       MOV       DPTR,#tempDataLen
   \   0000F2   E0           MOVX      A,@DPTR
   \   0000F3   F8           MOV       R0,A
   \   0000F4   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000F7   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000FA   D0E0         POP       A
   \   0000FC   F0           MOVX      @DPTR,A
   \   0000FD   90....       MOV       DPTR,#tempDataLen
   \   000100   E0           MOVX      A,@DPTR
   \   000101   04           INC       A
   \   000102   F0           MOVX      @DPTR,A
    263          
    264                  /* Check number of bytes left in the Rx buffer */
    265                  bytesInRxBuffer = Hal_UART_RxBufLen(port);
   \   000103                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000103   EE           MOV       A,R6
   \   000104   F9           MOV       R1,A
   \   000105   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   000108   EA           MOV       A,R2
   \   000109   FF           MOV       R7,A
    266          
    267                  /* If the remain of the data is there, read them all, otherwise, just read enough */
    268                  if (bytesInRxBuffer <= LEN_Token - tempDataLen)
   \   00010A   90....       MOV       DPTR,#LEN_Token
   \   00010D   E0           MOVX      A,@DPTR
   \   00010E   F8           MOV       R0,A
   \   00010F   90....       MOV       DPTR,#tempDataLen
   \   000112   E0           MOVX      A,@DPTR
   \   000113   FA           MOV       R2,A
   \   000114   E8           MOV       A,R0
   \   000115   C3           CLR       C
   \   000116   9A           SUBB      A,R2
   \   000117   F8           MOV       R0,A
   \   000118   95E0         SUBB      A,0xE0 /* A   */
   \   00011A   F9           MOV       R1,A
   \   00011B   EF           MOV       A,R7
   \   00011C   FA           MOV       R2,A
   \   00011D   C3           CLR       C
   \   00011E   E8           MOV       A,R0
   \   00011F   9A           SUBB      A,R2
   \   000120   E9           MOV       A,R1
   \   000121   9400         SUBB      A,#0x0
   \   000123   A2D2         MOV       C,0xD0 /* PSW */.2
   \   000125   65D0         XRL       A,PSW
   \   000127   33           RLC       A
   \   000128   4010         JC        ??MT_UartProcessZToolData_11
    269                  {
    270                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], bytesInRxBuffer);
   \   00012A                ; Setup parameters for call to function HalUARTRead
   \   00012A   EF           MOV       A,R7
   \   00012B   FC           MOV       R4,A
   \   00012C   7D00         MOV       R5,#0x0
   \   00012E   E0           MOVX      A,@DPTR
   \   00012F   F8           MOV       R0,A
   \   000130   12....       LCALL     ?Subroutine1 & 0xFFFF
    271                    tempDataLen += bytesInRxBuffer;
   \                     ??CrossCallReturnLabel_0:
   \   000133   90....       MOV       DPTR,#tempDataLen
   \   000136   E0           MOVX      A,@DPTR
   \   000137   2F           ADD       A,R7
   \   000138   8016         SJMP      ??MT_UartProcessZToolData_12
    272                  }
    273                  else
    274                  {
    275                    HalUARTRead (port, &pMsg->msg[MT_RPC_FRAME_HDR_SZ + tempDataLen], LEN_Token - tempDataLen);
   \                     ??MT_UartProcessZToolData_11:
   \   00013A   E0           MOVX      A,@DPTR
   \   00013B   F8           MOV       R0,A
   \   00013C                ; Setup parameters for call to function HalUARTRead
   \   00013C   90....       MOV       DPTR,#LEN_Token
   \   00013F   E0           MOVX      A,@DPTR
   \   000140   C3           CLR       C
   \   000141   98           SUBB      A,R0
   \   000142   FC           MOV       R4,A
   \   000143   95E0         SUBB      A,0xE0 /* A   */
   \   000145   FD           MOV       R5,A
   \   000146   12....       LCALL     ?Subroutine1 & 0xFFFF
    276                    tempDataLen += (LEN_Token - tempDataLen);
   \                     ??CrossCallReturnLabel_1:
   \   000149   90....       MOV       DPTR,#LEN_Token
   \   00014C   E0           MOVX      A,@DPTR
   \   00014D   90....       MOV       DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_12:
   \   000150   F0           MOVX      @DPTR,A
    277                  }
    278          
    279                  /* If number of bytes read is equal to data length, time to move on to FCS */
    280                  if ( tempDataLen == LEN_Token )
   \   000151   E0           MOVX      A,@DPTR
   \   000152   F8           MOV       R0,A
   \   000153   90....       MOV       DPTR,#LEN_Token
   \   000156   E0           MOVX      A,@DPTR
   \   000157   68           XRL       A,R0
   \   000158   6003         JZ        $+5
   \   00015A   02....       LJMP      ??MT_UartProcessZToolData_0 & 0xFFFF
    281                      state = FCS_STATE;
   \                     ??MT_UartProcessZToolData_10:
   \   00015D   90....       MOV       DPTR,#state
   \   000160   7405         MOV       A,#0x5
   \   000162   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    282          
    283                  break;
    284          
    285                case FCS_STATE:
    286          
    287                  FSC_Token = ch;
   \                     ??MT_UartProcessZToolData_9:
   \   000165   85..82       MOV       DPL,?XSP + 0
   \   000168   85..83       MOV       DPH,?XSP + 1
   \   00016B   E0           MOVX      A,@DPTR
   \   00016C   90....       MOV       DPTR,#FSC_Token
   \   00016F   12....       LCALL     ?Subroutine4 & 0xFFFF
    288          
    289                  /* Make sure it's correct */
    290                  if ((MT_UartCalcFCS ((uint8*)&pMsg->msg[0], MT_RPC_FRAME_HDR_SZ + LEN_Token) == FSC_Token))
   \                     ??CrossCallReturnLabel_9:
   \   000172   2403         ADD       A,#0x3
   \   000174   F9           MOV       R1,A
   \   000175   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000178   FA           MOV       R2,A
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   FB           MOV       R3,A
   \   00017C   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   00017F   E9           MOV       A,R1
   \   000180   F8           MOV       R0,A
   \   000181   90....       MOV       DPTR,#FSC_Token
   \   000184   E0           MOVX      A,@DPTR
   \   000185   68           XRL       A,R0
   \   000186   90....       MOV       DPTR,#pMsg
   \   000189   700F         JNZ       ??MT_UartProcessZToolData_13
    291                  {
    292                    osal_msg_send( App_TaskID, (byte *)pMsg );
   \   00018B                ; Setup parameters for call to function osal_msg_send
   \   00018B   E0           MOVX      A,@DPTR
   \   00018C   FA           MOV       R2,A
   \   00018D   A3           INC       DPTR
   \   00018E   E0           MOVX      A,@DPTR
   \   00018F   FB           MOV       R3,A
   \   000190   90....       MOV       DPTR,#App_TaskID
   \   000193   E0           MOVX      A,@DPTR
   \   000194   F9           MOV       R1,A
   \   000195   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   000198   8008         SJMP      ??MT_UartProcessZToolData_14
    293                  }
    294                  else
    295                  {
    296                    /* deallocate the msg */
    297                    osal_msg_deallocate ( (uint8 *)pMsg );
   \                     ??MT_UartProcessZToolData_13:
   \   00019A                ; Setup parameters for call to function osal_msg_deallocate
   \   00019A   E0           MOVX      A,@DPTR
   \   00019B   FA           MOV       R2,A
   \   00019C   A3           INC       DPTR
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   FB           MOV       R3,A
   \   00019F   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    298                  }
    299          
    300                  /* Reset the state, send or discard the buffers at this point */
    301                  state = SOP_STATE;
   \                     ??MT_UartProcessZToolData_14:
   \   0001A2   90....       MOV       DPTR,#state
   \   0001A5   E4           CLR       A
   \   0001A6   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    302          
    303                  break;
    304          
    305                default:
    306                 break;
    307              }
    308            }
    309          }
   \                     ??MT_UartProcessZToolData_3:
   \   0001A9   7401         MOV       A,#0x1
   \   0001AB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001AE   7F02         MOV       R7,#0x2
   \   0001B0   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_msg_allocate
   \   000001                ; Setup parameters for call to function MT_UartCalcFCS
   \   000001   90....       MOV       DPTR,#LEN_Token
   \   000004   E0           MOVX      A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   90....       MOV       DPTR,#pMsg
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FA           MOV       R2,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F583         MOV       DPH,A
   \   000009   8A82         MOV       DPL,R2
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000003   F8           MOV       R0,A
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   F583         MOV       DPH,A
   \   000008   8882         MOV       DPL,R0
   \   00000A   A3           INC       DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV       DPTR,#pMsg
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F583         MOV       DPH,A
   \   000009   8882         MOV       DPL,R0
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000003   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000006   AA82         MOV       R2,DPL
   \   000008   AB83         MOV       R3,DPH
   \   00000A   EE           MOV       A,R6
   \   00000B   F9           MOV       R1,A
   \   00000C   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   28           ADD       A,R0
   \   000002   FA           MOV       R2,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   3400         ADDC      A,#0x0
   \   000007   8A82         MOV       DPL,R2
   \   000009   F583         MOV       DPH,A
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   22           RET
    310          
    311          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    312          /***************************************************************************************************
    313           * @fn      MT_UartProcessZAppData
    314           *
    315           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    316           *          |  1  |  2   |       1         |  1   |
    317           *
    318           *          Parses the data and determine either is SPI or just simply serial data
    319           *          then send the data to correct place (MT or APP)
    320           *
    321           * @param   port    - UART port
    322           *          event   - Event that causes the callback
    323           *
    324           *
    325           * @return  None
    326           ***************************************************************************************************/
    327          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    328          {
    329          
    330            osal_event_hdr_t  *msg_ptr;
    331            uint16 length = 0;
    332            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    333          
    334            /*
    335               If maxZAppBufferLength is 0 or larger than current length
    336               the entire length of the current buffer is returned.
    337            */
    338            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    339            {
    340              length = MT_UartMaxZAppBufLen;
    341            }
    342            else
    343            {
    344              length = rxBufLen;
    345            }
    346          
    347            /* Verify events */
    348            if (event == HAL_UART_TX_FULL)
    349            {
    350              // Do something when TX if full
    351              return;
    352            }
    353          
    354            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    355            {
    356              if ( App_TaskID )
    357              {
    358                /*
    359                   If Application is ready to receive and there is something
    360                   in the Rx buffer then send it up
    361                */
    362                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    363                {
    364                  /* Disable App flow control until it processes the current data */
    365                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    366          
    367                  /* 2 more bytes are added, 1 for CMD type, other for length */
    368                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    369                  if ( msg_ptr )
    370                  {
    371                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    372                    msg_ptr->status = length;
    373          
    374                    /* Read the data of Rx buffer */
    375                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    376          
    377                    /* Send the raw data to application...or where ever */
    378                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    379                  }
    380                }
    381              }
    382            }
    383          }
    384          
    385          /***************************************************************************************************
    386           * @fn      SPIMgr_ZAppBufferLengthRegister
    387           *
    388           * @brief
    389           *
    390           * @param   maxLen - Max Length that the application wants at a time
    391           *
    392           * @return  None
    393           *
    394           ***************************************************************************************************/
    395          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    396          {
    397            /* If the maxLen is larger than the RX buff, something is not right */
    398            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    399              MT_UartMaxZAppBufLen = maxLen;
    400            else
    401              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    402          }
    403          
    404          /***************************************************************************************************
    405           * @fn      SPIMgr_AppFlowControl
    406           *
    407           * @brief
    408           *
    409           * @param   status - ready to send or not
    410           *
    411           * @return  None
    412           *
    413           ***************************************************************************************************/
    414          void MT_UartAppFlowControl ( bool status )
    415          {
    416          
    417            /* Make sure only update if needed */
    418            if (status != MT_UartZAppRxStatus )
    419            {
    420              MT_UartZAppRxStatus = status;
    421            }
    422          
    423            /* App is ready to read again, ProcessZAppData have to be triggered too */
    424            if (status == MT_UART_ZAPP_RX_READY)
    425            {
    426              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    427            }
    428          
    429          }
    430          
    431          #endif //ZAPP
    432          
    433          /***************************************************************************************************
    434          ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     11   MT_UartCalcFCS
      2     29   MT_UartInit
        2     29   -> HalUARTOpen
      1     11   MT_UartProcessZToolData
        0     11   -> HalUARTRead
        0     11   -> Hal_UART_RxBufLen
        0     11   -> MT_UartCalcFCS
        0     11   -> osal_msg_allocate
        0     11   -> osal_msg_deallocate
        0     11   -> osal_msg_send
      2      0   MT_UartRegisterTaskID


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?Subroutine0
      16  ?Subroutine1
      12  ?Subroutine2
       4  ?Subroutine3
       6  ?Subroutine4
      15  ?Subroutine5
      15  ?Subroutine6
      14  ?Subroutine7
       1  App_TaskID
       2  CMD_Token
       1  FSC_Token
       1  LEN_Token
      33  MT_UartCalcFCS
     110  MT_UartInit
     435  MT_UartProcessZToolData
      11  MT_UartRegisterTaskID
       2  pMsg
       1  state
       1  tempDataLen
      24  -- Other

 
 678 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   9 bytes in segment XDATA_Z
 
  24 bytes of CODE     memory
 678 bytes of HUGECODE memory
   9 bytes of XDATA    memory

Errors: none
Warnings: none
